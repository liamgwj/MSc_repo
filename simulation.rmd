---
title: "Simulate phylogeny and geographic distribution of host plants"
author: "Liam Johnson"
date: "2021-05-10"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Background


# Resources

The code presented here was informed by the following online resources:

# Setup

## Load packages
```{r message=FALSE}
library(ape)
library(geiger)
library(TreeSim)

library(landscapeR)
library(raster)

library(castor)

library(samc)
```


## Session information

Inserted `eval = F` into chunk header.. this can be changed to T when needed. 

```{r get_info, eval = F}
sessionInfo()
```

# Methods: input data

## Simulate host phylogeny

Specify the parameters for the simulation
```{r define_params}
ntips <- 20 # number of tips on each simulated phylogeny
numbsim <- 1 # number of phylogenies to simulate
lambda <- 0.1 # speciation rate
mu <- 0 # extinction rate
```

Simulate the phylogeny (output is a list, in this case containing only one phylogeny)
```{r sim_phylo}
phy <- sim.bd.taxa(ntips, numbsim, lambda, mu, frac = 1, complete = TRUE, stochsampling = FALSE)
```


## Simulate trait evolution

This function takes a phylogeny as input, and simulates the evolution of a trait on the phylogeny

Specify simulation parameters
```{r phylo_params}
q <- list(rbind(c(-.03, .03), c(.03, -.03))) # transition matrix
```

Simulate character evolution
```{r sim_char_evol}
compatible <- sim.char(phy[[1]], q, model="discrete", nsim = 1)
```


Plot the simulated phylogeny with character states shown in colour
```{r plot_phylo1, fig.width = 6, fig.height = 8}
plot(phy[[1]], tip.color=compatible)
```


We will consider tips with character state '2' (shown in red) to be compatible hosts, while tips with state '1' (in black) are not compatible.

Identify host names and indexes to use later
```{r host_info}
host_indexes <- which(compatible == 2)

host_names <- rownames(compatible)[host_indexes]
```


## Simulate tip geographic distributions

For every tip on the phylogeny, we will simulate a raster map representing the species' presence/absence in cells covering a hypothetical geographic area

```{r create_presabs_rasters}
occurrence <- vector("list", length = length(phy[[1]]$tip.label)) # create a list to hold the rasters
names(occurrence) <- phy[[1]]$tip.label # assign each item a tip name

empty_raster <- raster(matrix(0, 100, 100), xmn = 0, xmx = 10, ymn = 0, ymx = 10) # create an empty raster to fill with presence/absence for each species (reused)
```

Loop to simulate occurrence for each tip. Number of patches and patch size are sampled randomly for each species from the ranges specified, and warnings are disabled to avoid messages generated when patches overlap.
```{r sim_species_dist, warning = FALSE}
for(i in 1:length(occurrence)){
    np <- sample(1:10, 1) # number of patches
    sz <- sample(10:250, 1) # size of each patch
    occurrence[[i]] <- makeClass(empty_raster, npatch = np, size = sz)
}
```

Plot the distribution map generated for each tip. Compatible hosts are labeled in red.
```{r fig.width = 6, fig.height = 14}
par(mfrow=c(5,2))
for(i in 1:length(occurrence)){
    title_colour <- "black"
    if(names(occurrence[i])%in%host_names){
        title_colour <- "red"}
    plot(occurrence[[i]], main=names(occurrence[i]), col.main=title_colour)
}
```


## Calculate available habitat when all compatible hosts are considered

For now, we'll consider cell suitability to be equivalent to the number of compatible hosts present in each cell, calculated by summing the host rasters.

```{r calc_hab_suitability}
host_occurrence <- occurrence[host_indexes] # select only compatible host rasters

host_sum <- empty_raster # initiate the summed map

for(i in 1:length(host_occurrence)){
host_sum <- host_sum + host_occurrence[[i]] # add the remaining host rasters
}
```

Plot the summed raster - cell values are the number of compatible hosts present
```{r plot_habitat_suit, fig.width = 6, fig.height = 5.5}
plot(host_sum)
```


This map can now be used to measure "true" habitat values (connectivity etc.)

# Methods: calculating connectivity


## Measure true connectivity 


Generate absorption raster - for now, we'll have uniform minimal absorption
```{r absorb_raster, fig.width = 6, fig.height = 5.5}
absorp <- raster(matrix(0.005, 100, 100), xmn=0, xmx=10, ymn=0, ymx=10)

plot(absorp)
```


generate resistance raster
```{r resist_raster, fig.width = 6, fig.height = 5.5}
resist <- raster(matrix(length(host_names) + 1, 100, 100), xmn = 0, xmx = 10, ymn = 0, ymx = 10) - host_sum

plot(resist)
```


create samc object to feed into analysis calculations
```{r create_samc}
samc_obj <- samc(
              resistance = resist,
              absorption = absorp,
              latlon = FALSE,
              tr_fun = function(x) 1/mean(x),
              override = FALSE,
              directions = 8
)

str(samc_obj)
```


```{r prob_occurence, fig.width = 6, fig.height = 5.5}
# Convert the occupancy data to probability of occurrence
occ_prob_data <- 1 - 1/(host_sum+1)

plot(occ_prob_data)
```


calculate long term dispersal
```{r long_dispersal}
long_disp <- dispersal(samc_obj, occ_prob_data)
```


plot long term dispersal
```{r plot_long_dispersal, fig.width = 6, fig.height = 5.5}
long_disp_map <- map(samc_obj, long_disp)

plot(long_disp_map)
```


## Predict connectivity with incomplete host info


The following sections eliminate some hosts from the calculated habitat, use the phylogeny to predict potential hosts, then recalculate connectivity.


### Eliminate some known hosts

```{r}
known_host_indexes <- sample(host_indexes, round(length(host_indexes)/2, 0)) # keep roughly 1/2 of true hosts

known_host_names <- rownames(compatible)[known_host_indexes]
```


### Recalculate estimated available habitat

```{r}
known_host_occurrence <- occurrence[known_host_indexes]

known_host_sum <- empty_raster # initiate

for(i in 1:length(known_host_occurrence)){
known_host_sum <- known_host_sum + known_host_occurrence[[i]]
}
```

Plot the summed raster
```{r fig.width=6, fig.height=6}
plot(known_host_sum)
```

The maximum value is reduced, but the colour gradient spans the same range - this makes the maps harder to compare and should be fixed

* See this [stackexchange](https://stackoverflow.com/questions/36671499/color-ramp-with-the-same-colour-scale-across-different-plots-in-r)

### Revisit phylogeny 

Replot the phylogeny with non-host tips in black, "known" hosts in red and "unknown" hosts in blue

```{r fig.width=6, fig.height=8}
tip_cols <- compatible
tip_cols[setdiff(host_indexes, known_host_indexes)] <- 4

plot(phy[[1]], tip.color=tip_cols)
```

### Calculate phylogenetic distances separating each tip from nearest known host

```{r}
# get all pairwise distances
dist <- get_all_pairwise_distances(phy[[1]], only_clades=phy[[1]]$tip.label)

# remove duplicate distances (since a-b and b-a are equivalent) and convert to data.frame
dist2 <- matrix(dist, ncol = length(phy[[1]]$tip.label), dimnames = list(phy[[1]]$tip.label, phy[[1]]$tip.label))

dist2[col(dist2) == row(dist2) | upper.tri(dist2)] <- NA

sp <- subset(as.data.frame.table(dist2), !is.na(Freq)) 

names(sp) <- c("sp2", "sp1", "dist")

# lists of hosts
host_names <- phy[[1]]$tip.label[known_host_indexes]

# set up data frame
out <- data.frame(tip = phy[[1]]$tip.label)
out$minDist <- NA

# fill with distances
for(i in 1:length(phy[[1]]$tip.label)){
    
dists <- sp[which(sp$sp1==phy[[1]]$tip.label[i]|sp$sp2==phy[[1]]$tip.label[i]),]

dh <- dists[which(dists$sp1%in%host_names&!dists$sp1==phy[[1]]$tip.label[i]|dists$sp2%in%host_names&!dists$sp2==phy[[1]]$tip.label[i]),]

out$minDist[i] <- min(dh$dist)
}

out[order(out$minDist),]
```

> This is not a good phylogenetic prediction method - alter to allow adding potential hosts sequentially according to their PD from known hosts

Calculate mean nearest host distance among known hosts
```{r}
host_ntd <- mean(out$minDist[known_host_indexes])
```

Identify non-known host tips within mean host ntd
```{r}
potential_host_indexes <- as.numeric(rownames(out[which(out$minDist<=host_ntd & !out$tip%in%known_host_names),]))
```


Replot the phylogeny with non-host tips in black, "known" hosts in red, "unknown" hosts in blue, "unknown" hosts that are considered potential hosts in yellow, and non-hosts that are considered potential hosts in pink
```{r fig.width = 6, fig.height = 8}
tip_cols2 <- tip_cols

tip_cols2[setdiff(potential_host_indexes, host_indexes)] <- 6

tip_cols2[intersect(potential_host_indexes, host_indexes)] <- 7

plot(phy[[1]], tip.color=tip_cols2)
```


### Recalculate available habitat including potential hosts

```{r}
potential_host_occurrence <- occurrence[c(potential_host_indexes, known_host_indexes)]

potential_host_sum <- empty_raster # initiate

for(i in 1:length(potential_host_occurrence)){
potential_host_sum <- potential_host_sum + potential_host_occurrence[[i]]
}
```

Plot the summed raster
```{r fig.width=6, fig.height=5.5}
plot(potential_host_sum)
```


Again, need to fix the colour scheme

Add repeated connectivity measure and compare
