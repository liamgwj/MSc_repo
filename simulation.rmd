---
title: "Simulate phylogeny and geographic distribution of host plants"
author: "Liam Johnson"
date: "2021-05-10"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Background



# Resources
The code presented here was informed by the following online resources:



# Setup

## Load packages
```{r load_packages, message=FALSE}
library(ape)
library(geiger)
library(TreeSim)
library(picante)
library(castor)
library(landscapeR)
library(raster)
library(rasterVis)
library(ggplot2)
library(gridExtra)
library(viridis)
library(samc)
```


## Session information
```{r get_info, eval = F}
sessionInfo()
```



# Methods: input data

## Simulate host phylogeny

Specify the parameters for the simulation
```{r define_params}
ntips <- 20 # number of tips on each simulated phylogeny
numbsim <- 1 # number of phylogenies to simulate
lambda <- 0.1 # speciation rate
mu <- 0 # extinction rate
```

Simulate the phylogeny (output is a list, in this case containing only one phylogeny)
```{r sim_phylo}
host_phy_lst <- sim.bd.taxa(ntips, numbsim, lambda, mu, frac = 1, complete = TRUE, stochsampling = FALSE)

host_phy <- host_phy_lst[[1]]
```


## Simulate character evolution

This function takes a phylogeny as input, and simulates the evolution of a character on the phylogeny

Specify simulation parameters
```{r char_params}
q <- list(rbind(c(-.03, .03), c(.03, -.03))) # transition matrix
```

Simulate character evolution
```{r sim_char_evol}
traits_true <- sim.char(host_phy, q, model="discrete", nsim = 1)
```

Plot the simulated phylogeny with character states shown in colour
```{r plot_phylo1, fig.width = 6, fig.height = 6}
plot(host_phy, tip.color=traits_true)
```


We will consider tips with character state '2' (shown in red) to be compatible hosts, while tips with state '1' (in black) are not compatible.

Identify host names and indexes to use later
```{r host_info}
host_indexes <- which(traits_true == 2)

host_names <- rownames(traits_true)[host_indexes]
```


## Simulate tip geographic distributions

For every tip on the phylogeny, simulate a raster map representing the species' presence/absence in cells covering a hypothetical geographic area

Create empty rasters for all species
```{r create_species_rasters}
occurrence <- vector("list", length = length(phy[[1]]$tip.label)) # create a list to hold the rasters
names(occurrence) <- phy[[1]]$tip.label # assign each item a tip name

empty_raster <- raster(matrix(0, 100, 100), xmn = 0, xmx = 10, ymn = 0, ymx = 10) # create an empty raster to fill with presence/absence for each species (reused)
```

Loop to simulate occurrence for each tip. Number of patches and patch size are sampled randomly for each species from the ranges specified, and warnings are disabled to avoid messages generated when patches overlap.
```{r sim_species_dist, warning = FALSE}
for(i in 1:length(occurrence)){
    np <- sample(1:10, 1) # number of patches
    sz <- sample(10:250, 1) # size of each patch
    occurrence[[i]] <- makeClass(empty_raster, npatch = np, size = sz)
}
```

Plot the distribution map generated for each tip. Compatible hosts are labeled in red.
```{r plot_species_dist, fig.width = 6, fig.height = 14}
par(mfrow=c(5,2))
for(i in 1:length(occurrence)){
    title_colour <- "black"
    if(names(occurrence[i])%in%host_names){
        title_colour <- "red"}
    plot(occurrence[[i]], main=names(occurrence[i]), col.main=title_colour)
}
```


## Simulate incomplete host information


```{r}
traits_known <- traits_true

traits_known[sample(1:length(traits_true), round(length(traits_true)/3, 0))] <- NA # remove roughly 1/3 of trait values

known_host_indexes <- which(traits_known == 2)
known_host_names <- rownames(traits_known)[known_host_indexes]

missing_host_indexes <- intersect(host_indexes, which(is.na(traits_known)))

missing_nonhost_indexes <- setdiff(which(is.na(traits_known)), host_indexes)
```

Replot the phylogeny with known non-host tips in black, known hosts in red, unknown true hosts in yellow and unknown non-hosts blue
```{r fig.width=6, fig.height=6}
tip_cols <- traits_true
tip_cols[missing_host_indexes] <- "goldenrod"
tip_cols[missing_nonhost_indexes] <- "royalblue"

plot(host_phy, tip.color=tip_cols)
```



# Methods: phylogenetic prediction

Prepare trait data - transpose and remove species with unknown values
```{r}
comp_unknown <- t(na.omit(as.data.frame(traits_known)))[1,]
```

Use ancestral state reconstruction to estimate missing trait values
```{r}
comp_ancPhyEst <- phyEstimateDisc(phy = host_phy,
                                  trait = comp_unknown,
                                  best.state= TRUE,
                                  cutoff = 0.5)
```

Combine estimated trait values with known values
```{r}
traits_estimate <- traits_known

traits_estimate[which(is.na(traits_estimate))] <- as.numeric(comp_ancPhyEst$estimated.state)

potential_host_indexes <- setdiff(which(traits_estimate == 2), known_host_indexes)
```

Replot and compare phylogenies
```{r fig.width = 6, fig.height = 6}
par(mfrow=c(1,2))

plot(host_phy, tip.color=tip_cols)

plot(host_phy, tip.color=traits_estimate)
```



# Methods: calculate connectivity

## Calculate available habitat and connectivity when all compatible hosts are considered

For now, we'll consider cell suitability to be equivalent to the number of compatible hosts present in each cell, calculated by summing the host rasters.

Calculate habitat suitability (true hosts)
```{r calc_hab_suitability}
host_occurrence <- occurrence[host_indexes] # select only compatible host rasters

host_sum <- empty_raster # initiate the summed map

for(i in 1:length(host_occurrence)){
host_sum <- host_sum + host_occurrence[[i]] # add the remaining host rasters
}
```

Define connectivity calculation function (will be reused)
> I imagine this will have to be edited to return the intermediate objects as well... works for visual comparisons as it stands

```{r disp_fun}
disp_fun <- function(max_resistance, absorp_raster, host_raster){

    # generate resistance raster
resist <- raster(matrix(max_resistance, 100, 100), xmn = 0, xmx = 10, ymn = 0, ymx = 10) - host_raster

    # create samc object to feed into analysis calculations
samc_obj <- samc(
              resistance = resist,
              absorption = absorp_raster,
              latlon = FALSE,
              tr_fun = function(x) 1/mean(x),
              override = FALSE,
              directions = 8
)

    # Convert the occupancy data to probability of occurrence
occ_prob <- 1 - 1 / (host_raster + 1)

    # calculate long-term dispersal
disp <- dispersal(samc_obj, occ_prob)

    # map long-term dispersal
disp_map <- map(samc_obj, disp)

return(disp_map)
}
```

Generate absorption raster - for now, we'll have uniform minimal absorption
```{r absorp_raster}
absorp <- raster(matrix(0.005, 100, 100), xmn=0, xmx=10, ymn=0, ymx=10)
```

Calculate connectivity (true hosts)
```{r disp_calc}
disp_map_true <- disp_fun(max_resistance = length(phy[[1]]$tip.label) + 1,
                                absorp_raster = absorp,
                                host_raster = host_sum)
```


## Calculate habitat and connectivity using only known hosts

Calculate habitat suitability (known hosts)
```{r}
known_host_occurrence <- occurrence[known_host_indexes]

known_host_sum <- empty_raster # initiate

for(i in 1:length(known_host_occurrence)){
known_host_sum <- known_host_sum + known_host_occurrence[[i]]
}
```

Calculate connectivity (known hosts)
```{r disp_calc}
disp_map_known <- disp_fun(max_resistance = length(phy[[1]]$tip.label) + 1,
                                absorp_raster = absorp,
                                host_raster = known_host_sum)
```


## Calculate habitat and connectivity using known and phylogenetically predicted hosts 

Calculate habitat suitability (known + potential hosts)
```{r}
potential_host_occurrence <- occurrence[c(potential_host_indexes, known_host_indexes)]

potential_host_sum <- empty_raster # initiate

for(i in 1:length(potential_host_occurrence)){
potential_host_sum <- potential_host_sum + potential_host_occurrence[[i]]
}
```

Calculate connectivity (known + potential hosts)
```{r long_disp_calc}
disp_map_pred <- disp_fun(max_resistance = length(phy[[1]]$tip.label) + 1,
                                absorp_raster = absorp,
                                host_raster = potential_host_sum)
```


## Compare available habitat

We can now compare three habitat suitability maps - the true habitat including all hosts, the known-host only habitat, and the phylogenetically-predicted potential host habitat:

Identify upper limit for common colour scale
```{r}
hab_max_value <- max(cellStats(host_sum, "max"), cellStats(potential_host_sum, "max"))
```

True hosts
```{r plot_habitat_suit}
p_all_host_hab <- gplot(host_sum) + 
                  geom_tile(aes(fill=value)) +
                  scale_fill_viridis(limits = c(0, hab_max_value),
                      option="B")
```

Known hosts
```{r plot_known_hosts}
p_known_host_hab <- gplot(known_host_sum) + 
                    geom_tile(aes(fill=value)) +
                    scale_fill_viridis(limits=c(0, hab_max_value),
                        option="B")
```

Known + predicted hosts
```{r plot_knownpred_hosts}
p_phy_host_hab <- gplot(potential_host_sum) + 
                  geom_tile(aes(fill=value)) +
                  scale_fill_viridis(limits=c(0, hab_max_value),
                      option="B")
```

Multiplot
```{r compare_maps, fig.width = 6, fig.height = 5.5}
grid.arrange(p_all_host_hab + ggtitle("true hosts"),
             p_known_host_hab + ggtitle("known hosts"),
             p_phy_host_hab + ggtitle("known + predicted hosts"),
             ncol=2)
```


## Compare connectivity 

Identify upper limit for common colour scale
```{r}
disp_max_value <- max(cellStats(disp_map_true, "max"), cellStats(disp_map_pred, "max"))
```

True hosts
```{r plot_true_dispersal}
p_disp_true <- gplot(disp_map_true) +
                  geom_tile(aes(fill=value)) +
                    scale_fill_viridis(limits = c(0, disp_max_value),
                                       option="B")
```

Known hosts
```{r plot_known_dispersal}
p_disp_known <- gplot(disp_map_known) +
                  geom_tile(aes(fill=value)) +
                    scale_fill_viridis(limits = c(0, disp_max_value),
                                       option="B")
```

Known + predicted hosts
```{r plot_pred_dispersal}
p_disp_pred <- gplot(disp_map_pred) + 
                  geom_tile(aes(fill = value)) +
                    scale_fill_viridis(limits = c(0, disp_max_value),
                                       option = "B")
```

Multiplot
```{r compare_disp, fig.width = 6, fig.height = 5}
grid.arrange(p_disp_true + ggtitle("true hosts"),
             p_disp_known + ggtitle("known hosts"),
             p_disp_pred + ggtitle("known + predicted hosts"),
             ncol=2)
```

