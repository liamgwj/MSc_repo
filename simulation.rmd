---
title: "Simulate phylogeny and geographic distribution of host plants"
author: "Liam Johnson"
date: "2021-05-10"
output: html_document
---

```{r setup, include=FALSE, purl=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

to save as r script: knitr::purl("simulation.rmd", documentation=2)

# Background



# Resources
The code presented here was informed by the following online resources:

LandscapeR documentation: https://cran.r-project.org/web/packages/landscapeR/vignettes/landscapeR.html

Omniscape documentation: https://docs.circuitscape.org/Omniscape.jl/stable/



# Setup

## Load packages
```{r load_packages, message=FALSE}
library(ape)
library(geiger)
library(caper)
library(picante)
library(TreeSim)

library(raster)
library(rasterVis)
library(rgdal)
library(landscapeR)

library(ggplot2)
library(gridExtra)
library(viridis)

library(dplyr)

library(XRJulia)
```


## Session information
```{r get_info, eval = F}
sessionInfo()
```



# Methods: input data

```{r}
trait_rate <- 0.1

proportion_missing <- 0.3

cooccurrence_pattern <- "dispersed"
```


```{r eval = F}
input_params <- expand.grid(trait_rate = c(0.05, 0.1, 0.2, 0.3),
                            prop_missing = c(0.05, 0.1, 0.25, 0.5),
                            coocurrence_pat = c("clustered",
                                                "random",
                                                "dispersed"))
```

```{r eval = F}
for(i in 1:nrow(input_params)){
    
    trait_rate <- input_params$trait_rate[i]
    
    proportion_missing <- input_params$prop_missing[i]
    
    cooccurrence_pattern <- input_params$coocurrence_pat[i]
    
    
```

## Simulate host phylogeny

Simulate the phylogeny (output is a list, in this case containing only one phylogeny)
```{r sim_phylo, fig.width = 6, fig.height = 6}
host_phy_lst <- sim.bd.taxa(n = 20, # number of tips on each phylogeny
                            numbsim = 1, # number of phylogenies
                            lambda = 0.2, # speciation rate
                            mu = 0.1, # extinction rate
                            complete = FALSE) #,
                            # stochsampling = FALSE,
                            # frac = 0.8)

host_phy <- host_phy_lst[[1]]

# plot(host_phy)
```


## Simulate character evolution

This function takes a phylogeny as input, and simulates the evolution of a discrete character on the phylogeny

```{r}
traits_true <- rTraitDisc(phy = host_phy,
                          model = "ER",
                          k = 2,
                          rate = trait_rate,
                          states = c("NonHost", "Host"),
                          #freq = rep(1/k, k),
                          ancestor = FALSE,
                          root.value = 1)

traits_true <- data.frame(hostStatus = traits_true)
traits_true$tip <- rownames(traits_true)
```

Plot the simulated phylogeny with character states shown in colour
```{r plot_phylo1, fig.width = 6, fig.height = 6}
tipcol_traits_true <- data.frame(tipcol = rep("black", nrow(traits_true)))
tipcol_traits_true$tipcol[which(traits_true$hostStatus == "Host")] <- "red"

plot(host_phy, tip.color = tipcol_traits_true$tipcol)
```


Identify host names and indexes to use later
```{r host_info}
host_indexes <- which(traits_true$hostStatus == "Host")

host_names <- rownames(traits_true)[host_indexes]
```

Assess phylogenetic signal
```{r}
host_signal <- phylo.d(data = traits_true,
                       phy = host_phy,
                       names.col = tip,
                       binvar = hostStatus,
                       permut = 1000,
                       rnd.bias = NULL)
```


## Simulate tip geographic distributions

For every tip on the phylogeny, simulate a raster map representing the species' presence/absence in cells covering a hypothetical geographic area



### Simple simulation of random patchy distributions

Create empty rasters for all species
```{r create_species_rasters}
occurrence <- vector("list", length = length(host_phy$tip.label)) # create a list to hold the rasters
names(occurrence) <- host_phy$tip.label # assign each item a tip name

empty_raster <- raster(matrix(0, 100, 100), xmn = 0, xmx = 10, ymn = 0, ymx = 10) # create an empty raster to fill with presence/absence for each species (reused)
```

Loop to simulate occurrence for each tip. Number of patches and patch size are sampled randomly for each species from the ranges specified, and warnings are disabled to avoid messages generated when patches overlap.
```{r sim_species_dist, warning = FALSE}

seed_locations <- sample(1:length(empty_raster[]), 10*length(host_phy$tip.label))

for(i in 1:length(occurrence)){
    np <- sample(1:10, 1) # number of patches
    sz <- sample(10:250, 1) # size of each patch
    
    if(cooccurrence_pattern == "clustered"){
    seed_loc_subset <- sample(seed_locations[1:10], np)}
    
    if(cooccurrence_pattern == "random"){
    seed_loc_subset <- sample(1:length(empty_raster[]), np)}
    
    if(cooccurrence_pattern == "dispersed"){
    if(i==1){ seed_loc_subset <- seed_locations[i:np]
    }else{ seed_loc_subset <- seed_locations[(((i-1)*10)+1):(((i-1)*10)+np)]}}
    
    occurrence[[i]] <- makeClass(empty_raster,
                                 npatch = np,
                                 size = sz,
                                 pts = seed_loc_subset)
}
```

Plot the distribution map generated for each tip. Compatible hosts are labeled in red.
```{r plot_species_dist, fig.width = 6, fig.height = 14}
par(mfrow=c(5,2))
for(i in 1:length(occurrence)){
    title_colour <- "black"
    if(names(occurrence[i])%in%host_names){
        title_colour <- "red"}
    plot(occurrence[[i]], main=names(occurrence[i]), col.main=title_colour)
}
```


## Simulate incomplete host information


```{r}
traits_known <- traits_true

traits_known$hostStatus[sample(1:length(traits_true$hostStatus), round(length(traits_true$hostStatus)*proportion_missing, 0))] <- NA

known_host_indexes <- which(traits_known$hostStatus == "Host")
known_host_names <- rownames(traits_known)[known_host_indexes]

missing_host_indexes <- intersect(host_indexes, which(is.na(traits_known$hostStatus)))

missing_nonhost_indexes <- setdiff(which(is.na(traits_known$hostStatus)), host_indexes)
```

Replot the phylogeny with known non-host tips in black, known hosts in red, unknown true hosts in yellow and unknown non-hosts blue
```{r fig.width=6, fig.height=6}
tipcol_traits_known <- tipcol_traits_true
tipcol_traits_known$tipcol[missing_host_indexes] <- "goldenrod"
tipcol_traits_known$tipcol[missing_nonhost_indexes] <- "royalblue"

plot(host_phy, tip.color=tipcol_traits_known$tipcol)
```



# Methods: phylogenetic prediction

Prepare trait data - transpose and remove species with unknown values
```{r}
comp_unknown <- t(na.omit(traits_known))[1,]
```

Use ancestral state reconstruction to estimate missing trait values
```{r}
comp_ancPhyEst <- phyEstimateDisc(phy = host_phy,
                                  trait = comp_unknown,
                                  best.state= TRUE,
                                  cutoff = 0.5)
```

Combine estimated trait values with known values
```{r}
traits_estimate <- traits_known

comp_ancPhyEst$tip <- rownames(comp_ancPhyEst)

traits_estimate <- left_join(traits_estimate, comp_ancPhyEst, by = c("tip" = "tip"))

for(i in 1:nrow(traits_estimate)){
    if(is.na(traits_estimate$hostStatus[i])){
        traits_estimate$hostStatus[i] <- traits_estimate$estimated.state[i]
}}

potential_host_indexes <- setdiff(which(traits_estimate$hostStatus == "Host"), known_host_indexes)
```

Replot and compare phylogenies
```{r fig.width = 6, fig.height = 6}
tipcol_traits_estimate <- data.frame(tipcol = rep("black", nrow(traits_estimate)))
tipcol_traits_estimate$tipcol[which(traits_estimate$hostStatus == "Host")] <- "red"

par(mfrow=c(1,2))

plot(host_phy, tip.color = tipcol_traits_known$tipcol)

plot(host_phy, tip.color = tipcol_traits_estimate$tipcol)
```



# Methods: assess available habitat

## Calculate available habitat

For now, we'll consider cell suitability to be equivalent to the number of compatible hosts present in each cell, calculated by summing the host rasters.

Calculate habitat suitability (true hosts)
```{r calc_suitability_true}
host_occurrence <- occurrence[host_indexes] # select only compatible host rasters

host_sum <- empty_raster

for(i in 1:length(host_occurrence)){
host_sum <- host_sum + host_occurrence[[i]] # add the host rasters
}

host_sum_capped <- host_sum + 1 # value of 1 added to all cells to avoid division by zero when calculating connectivity

host_sum_capped[which(host_sum_capped[] > 4)] <- 4 # set all values > 4 to 4 -- result is that all cells containing 3+ hosts are considered equally suitable
```

Write suitability map to file

```{r write_suitability_true, warning=FALSE}
writeRaster(host_sum_capped, "omniscape/true_host_map", format = "GTiff", overwrite=TRUE)
```

Calculate habitat suitability (known hosts)
```{r calc_suitability_known}
known_host_occurrence <- occurrence[known_host_indexes]

known_host_sum <- empty_raster

for(i in 1:length(known_host_occurrence)){
known_host_sum <- known_host_sum + known_host_occurrence[[i]]
}

known_host_sum_capped <- known_host_sum + 1

known_host_sum_capped[which(known_host_sum_capped[] > 4)] <- 4
```

Write suitability map to file
```{r write_suitability_known, warning=FALSE}
writeRaster(known_host_sum_capped, "omniscape/known_host_map", format = "GTiff", overwrite=TRUE)
```

Calculate habitat suitability (known + potential hosts)
```{r calc_suitability_predicted}
predicted_host_occurrence <- occurrence[c(potential_host_indexes, known_host_indexes)]

predicted_host_sum <- empty_raster

for(i in 1:length(predicted_host_occurrence)){
predicted_host_sum <- predicted_host_sum + predicted_host_occurrence[[i]]
}

predicted_host_sum_capped <- predicted_host_sum + 1

predicted_host_sum_capped[which(predicted_host_sum_capped[] > 4)] <- 4
```

Write suitability map to file
```{r write_suitability_predicted, warning=FALSE}
writeRaster(predicted_host_sum_capped, "omniscape/predicted_host_map", format = "GTiff", overwrite=TRUE)
```


## Compare available habitat

We can now compare three habitat suitability maps - the true habitat including all hosts, the known-host only habitat, and the phylogenetically-predicted potential host habitat:

Identify upper limit for common colour scale
```{r suitability_colour_scale}
hab_max_value <- max(cellStats(host_sum, "max"), cellStats(predicted_host_sum, "max"))
```

True hosts
```{r plot_suitability_true}
p_all_host_hab <- gplot(host_sum) + 
                  geom_tile(aes(fill=value)) +
                  scale_fill_viridis(limits = c(0, hab_max_value),
                      option="B")
```

Known hosts
```{r plot_suitability_known}
p_known_host_hab <- gplot(known_host_sum) + 
                    geom_tile(aes(fill=value)) +
                    scale_fill_viridis(limits=c(0, hab_max_value),
                        option="B")
```

Known + predicted hosts
```{r plot_suitability_predicted}
p_phy_host_hab <- gplot(predicted_host_sum) + 
                  geom_tile(aes(fill=value)) +
                  scale_fill_viridis(limits=c(0, hab_max_value),
                      option="B")
```

Multiplot
```{r compare_suitability_maps, fig.width = 6, fig.height = 5.5}
grid.arrange(p_all_host_hab + ggtitle("true hosts"),
             p_known_host_hab + ggtitle("known hosts"),
             p_phy_host_hab + ggtitle("known + predicted hosts"),
             ncol=2)
```



# Methods: assess connectivity

At this point, we're ready to carry out the actual connectivity calculations using Omniscape/Julia.

Remove any files from previous runs
```{r}
if(file.exists("omniscape/true_host")){
    unlink("omniscape/true_host", recursive = TRUE)}

if(file.exists("omniscape/known_host")){
    unlink("omniscape/known_host", recursive = TRUE)}

if(file.exists("omniscape/predicted_host")){
    unlink("omniscape/predicted_host", recursive = TRUE)}
```

```{r julia_connectivity_true}
juliaUsing("Omniscape")

juliaCommand(
    paste("run_omniscape(\"",
          getwd(),
          "/omniscape/true_host.ini\"::String)",
          sep=""))
```


```{r julia_connectivity_known}
juliaCommand(
    paste("run_omniscape(\"",
          getwd(),
          "/omniscape/known_host.ini\"::String)",
          sep=""))
```


```{r julia_connectivity_predicted}
juliaCommand(
    paste("run_omniscape(\"",
          getwd(),
          "/omniscape/predicted_host.ini\"::String)",
          sep=""))
```



Here, we load the output connectivity maps and plot them for comparison.

Load maps
```{r load_connectivity_maps}
connect_true_host <- raster("omniscape/true_host/cum_currmap.tif")

connect_known_host <- raster("omniscape/known_host/cum_currmap.tif")

connect_predict_host <- raster("omniscape/predicted_host/cum_currmap.tif")
```

Identify upper limit for common colour scale
```{r connectivity_colour_scale}
disp_max_value <- max(cellStats(connect_true_host, "max"),
                      cellStats(connect_predict_host, "max"))
```

True hosts
```{r plot_connectivity_true}
p_connect_true_host <- gplot(connect_true_host) +
                  geom_tile(aes(fill=value)) +
                    scale_fill_viridis(limits = c(0, disp_max_value),
                                       option="B")
```

Known hosts
```{r plot_connectivity_known}
p_connect_known_host <- gplot(connect_known_host) +
                  geom_tile(aes(fill=value)) +
                    scale_fill_viridis(limits = c(0, disp_max_value),
                                       option="B")
```

Known + predicted hosts
```{r plot_connectivity_predicted}
p_connect_predict_host <- gplot(connect_predict_host) + 
                  geom_tile(aes(fill = value)) +
                    scale_fill_viridis(limits = c(0, disp_max_value),
                                       option = "B")
```

Multiplot
```{r compare_connectivity_maps, fig.width = 6, fig.height = 5}
grid.arrange(p_connect_true_host + ggtitle("true hosts"),
             p_connect_known_host + ggtitle("known hosts"),
             p_connect_predict_host + ggtitle("known + predicted hosts"),
             ncol=2)
```


# setup: simulate data

```{r}
trait_rate <- 0.1

proportion_missing <- 0.3

cooccurrence_pattern <- "dispersed"
```


```{r eval = F}
input_params <- expand.grid(trait_rate = c(0.05, 0.1, 0.2, 0.3),
                            prop_missing = c(0.05, 0.1, 0.25, 0.5),
                            coocurrence_pat = c("clustered",
                                                "random",
                                                "dispersed"))
```

```{r eval = F}
for(i in 1:nrow(input_params)){
    
    trait_rate <- input_params$trait_rate[i]
    
    proportion_missing <- input_params$prop_missing[i]
    
    cooccurrence_pattern <- input_params$coocurrence_pat[i]
    
    
```



Simulate host phylogenies
```{r sim_phylo, fig.width = 6, fig.height = 6}
host_phy_lst <- sim.bd.taxa(n = 20, # number of tips on each phylogeny
                            numbsim = 10, # number of phylogenies
                            lambda = 0.2, # speciation rate
                            mu = 0.1, # extinction rate
                            complete = FALSE) #,
                            # stochsampling = FALSE,
                            # frac = 0.8)
```

Simulate character evolution
```{r}
host_status_lst_true <- vector("list", length(host_phy_lst))

for(i in 1:length(host_phy_lst)){
     host_status_lst_true[[i]] <- rTraitDisc(phy = host_phy_lst[[i]],
                                        model = "ER",
                                        k = 2,
                                        rate = trait_rate,
                                        states = c("NonHost", "Host"),
                                        #freq = rep(1/k, k),
                                        ancestor = FALSE,
                                        root.value = 1)
}
```

Simulate geographic distributions for each tip
```{r create_species_rasters}
occurrence <- vector("list", length(host_phy_lst))

for(i in 1:length(occurrence)){
    occurrence[[i]] <- vector("list", length(host_phy_lst[[i]]$tip.label))
    
    names(occurrence[[i]]) <- host_phy_lst[[i]]$tip.label
    }

empty_raster <- raster(matrix(0, 100, 100),
                       xmn = 0, xmx = 10,
                       ymn = 0, ymx = 10)

for(i in 1:length(occurrence)){
    seed_locations <- sample(1:length(empty_raster[]),
                             10*length(host_phy_lst[[i]]$tip.label))
    
    for(j in 1:length(occurrence[[i]])){
        np <- sample(1:10, 1) # number of patches
        sz <- sample(10:250, 1) # size of each patch
        
        if(cooccurrence_pattern == "clustered"){
        seed_loc_subset <- sample(seed_locations[1:10], np)}
        
        if(cooccurrence_pattern == "random"){
        seed_loc_subset <- sample(1:length(empty_raster[]), np)}
        
        if(cooccurrence_pattern == "dispersed"){
        if(j==1){ seed_loc_subset <- seed_locations[j:np]
        }else{seed_loc_subset <-
            seed_locations[(((j-1)*10)+1):(((j-1)*10)+np)]}}
        
        occurrence[[i]][[j]] <- makeClass(empty_raster,
                                          npatch = np,
                                          size = sz,
                                          pts = seed_loc_subset)
}}
```

Simulate incomplete host information
```{r}
host_status_lst_known <- host_status_lst_true

for(i in 1:length(host_status_lst_known)){
    host_status_lst_known[[i]][sample(1:length(host_phy_lst[[i]]$tip.label), round(length(host_phy_lst[[i]]$tip.label)*proportion_missing, 0))] <- NA
}
```

Write simulated data to file
```{r warning=FALSE}
for(i in 1:length(host_phy_lst)){
    
    write.tree(host_phy_lst[[i]],
               paste0("output/sim_phylogenies/phy", i, ".nwk"))
    
    write.csv(data.frame(hostStatus = host_status_lst_true[[i]]),
              paste0("output/sim_hostStatus/true/phy", i,
                     "_hostStatusTrue.csv"))
    
    write.csv(data.frame(hostStatus = host_status_lst_known[[i]]),
              paste0("output/sim_hostStatus/known/phy", i,
                     "_hostStatusKnown.csv"))
    
    dir.create(paste0("output/sim_occurrence/phy", i))
    
    for(j in 1:length(host_phy_lst[[i]]$tip.label)){
        
        writeRaster(occurrence[[i]][[j]],
                    paste0("output/sim_occurrence/phy", i, "/",
                           host_phy_lst[[i]]$tip.label[j], "_occurrence"),
                    format = "GTiff", overwrite=TRUE)
}}
```


# phylogenetic prediction
Use ancestral state reconstruction to estimate missing trait values
```{r}
host_status_lst_estim <- vector("list", length(host_status_lst_known))

for(i in 1:length(host_status_lst_estim)){
    host_status_lst_estim[[i]]  <- phyEstimateDisc(phy = host_phy_lst[[i]],
                                    trait = na.omit(host_status_lst_known[[i]]),
                                    best.state = TRUE,
                                    cutoff = 0.5)
}
```

Identify all known and putative hosts
```{r}
host_names_lst <- vector("list", length(host_phy_lst))

for(i in 1:length(host_names_lst)){
    host_names_lst[[i]] <- c(
        host_phy_lst[[i]]$tip.label[which(host_status_lst_known[[i]] == "Host")],
        rownames(host_status_lst_estim[[i]])[which(host_status_lst_estim[[i]]$estimated.state == "Host")])
}

host_indexes_lst <- vector("list", length(host_phy_lst))

for(i in 1:length(host_names_lst)){
    host_indexes_lst[[i]] <- which(host_phy_lst[[i]]$tip.label %in%
                                       host_names_lst[[i]])
}
```


# reused habitat assessment workflow
## input data
## assess available habitat

For now, we'll consider cell suitability to be equivalent to the number of compatible hosts present in each cell, calculated by summing the host rasters.

Calculate habitat suitability
```{r calc_suitability_true}
num_hosts <- vector("list", length(host_phy_lst))

for(i in 1:length(num_hosts)){
    
    num_hosts[[i]] <- empty_raster + 1
    
    for(j in 1:length(host_phy_lst[[i]]$tip.label)){
        
        num_hosts[[i]] <- num_hosts[[i]] + occurrence[[i]][[j]]
}}

suitability <- num_hosts

for(i in 1:length(suitability)){
    suitability[[i]][which(suitability[[i]][] > 4)] <- 4
}
```

Write suitability map to file
```{r write_suitability_true, warning=FALSE}
for(i in 1:length(host_phy_lst)){
    
    writeRaster(num_hosts[[i]],
                paste0("output/sim_suitability/num_hosts/phy", i,
                       "_numHosts"),
                format = "GTiff", overwrite=TRUE)
    
    writeRaster(suitability[[i]],
                paste0("output/sim_suitability/suitability/phy", i,
                       "_suitability"),
                format = "GTiff", overwrite=TRUE)
}
```

## assess connectivity
```{r julia_connectivity_true}

for(i in 1:length(host_phy_lst)){

writeLines(paste0("resistance_file = ", getwd(),
            "/output/sim_suitability/suitability/phy", i, "_suitability.tif\n",
"radius = 20
block_size = 3
project_name = ", getwd(), "/omniscape/output_maps/phy", i, "_connectivity\n",
"source_from_resistance = true
resistance_is_conductance = true
calc_normalized_current = true
calc_flow_potential = true
parallelize = false
write_raw_currmap = true"),
            con = paste0("omniscape/ini_files/phy", i, ".ini"), sep="\n")
}
    
    
juliaUsing("Omniscape")

for(i in 1:length(host_phy_lst)){
    
    if(file.exists(paste0("omniscape/output_maps/phy", i, "_connectivity"))){
    unlink(paste0("omniscape/output_maps/phy", i, "_connectivity"),
           recursive = TRUE)}
    
    juliaCommand(
        paste0("run_omniscape(\"",
               getwd(),
               "/omniscape/ini_files/phy", i, ".ini\"::String)"))
}
```

